---
layout  : wiki
title   : Implementation patterns
summary :
date    : 2025-03-15 18:00:00 +0900
updated : 2025-03-15 18:00:00 +0900
tag     : programming
toc     : true
public  : true
parent  : [[how-to]]
latex   : true
---
* TOC
{:toc}

# Implementation patterns
<img alt="Image" src="https://github.com/user-attachments/assets/b78cabc4-5b39-4cc0-a933-b418fbdb4b21" />

## Class
> 클래스의 역사는 플라톤이 살았던 시대까지 거슬러 올라간다. 플라톤은 현실 세계에 존재하는 것은 클래스의 인스턴스일 뿐이라고 이야기했다.

- 클래스 : "이 데이터들은 함께 사용되는데, 그에 관련된 로직이 이것이다."라는 이야기를 하고 싶을 때 클래스를 사용한다.
- 단순한 상위클래스 이름 : 클래스 계층의 최상위에 위치하는 클래스 이름은 단순하게 짓는다.
- 한정적 하위클래스 이름 : 상위클래스와의 유사점과 차이점을 분명히 드러내는 이름을 사용한다.
- 추상 인터페이스 : 인터페이스와 구현을 분리한다.
- 인터페이스 : 자주 변하지 않는 추상 인터페이스에는 자바 인터페이스를 사용한다.
- 버전 인터페이스 : 하위인터페이스를 사용해 기존 인터페이스를 안전하게 확장한다.
- 추상 클래스 : 자주 바뀔 것 같은 추상 인터페이스에는 추상 클래스를 사용한다.
- 값 객체 : 산술 값처럼 동작하는 객체를 사용한다.
- 특화 : 관련된 연산 사이의 유사점 및 차이점을 분명하게 나타낸다.
- 하위클래스 : 1차원적 변화는 하위클래스를 사용해서 표현한다.
- 구현자 : 연산 내용이 바뀌었다면 기존 메소드를 오버라이드해서 사용한다.
- 내부 클래스 : 클래스 내부에서 유용하게 사용할 수 있는 코드를 모아 전용 클래스로 사용한다.
- 인스턴스별 행동 : 인스턴스에 따라 로직에 변화를 준다.
- 조건문 : 명시적 조건에 따라 로직에 변화를 준다.
- 위임 : 여러 종류의 객체 중 하나에 위임해서 로직에 변화를 준다.
- 플러그인 선택자 : 리플렉션을 이용한 메소드 호출로 로직에 변화를 준다.
- 익명 내부 클래스 : 필요한 메소드에서 한두 개의 메소드만 오버라이드하는 객체를 만들어서 사용한다.
- 라이브러리 클래스 : 마땅히 들어갈 곳이 없는 기능들을 묶어서 정적 메소드로 표현한다.

### 키워드 및 문장
- 메타포. ex) DrawingObject -> Figure, Figure 상속 -> Handle
- 클래스 이름은 코드의 내용을 반영해야 한다.
  - 이름 사이에 연관성이 없는 일련의 클래스는 이해하기도 기억하기도 어렵다.
- 구현이 아니라 인터페이스에 맞춰 코딩하라.
  - 설계상의 결정을 필요 이상으로 노출하지 말라는 뜻이다.