---
layout  : wiki
title   : Java에서 Kotlin으로
summary :
date    : 2024-09-11 13:00:00 +0900
updated : 2024-09-11 13:00:00 +0900
tag     : kotlin
toc     : true
public  : true
parent  : [[how-to]]
latex   : true
---
* TOC
{:toc}

# Java에서 Kotlin으로

## 코틀린의 결

### 특징

> 코틀린은 가변 상태를 변경하는 것보다 불변 데이터를 변환하는 쪽을 더 선호한다.

- 데이터 클래스를 사용하며 값 의미론을 제공하는 새로운 타입을 쉽게 정의할 수 있다.

> 코틀린은 동작을 명시적으로 작성하는 쪽을 더 선호한다.

- 코틀린에는 암시적인 타입 변환이 없다.
- 더 작은 데이터 타입을 더 큰 데이터 타입으로 자동으로 변환해 주지도 않는다.

자바는 정보 손실이 없으므로 int를 long으로 암시적으로 변환해 준다. 하지만 코틀린에서는 Int.toLong()을 명시적으로 호출해야 한다. 명시성을 선호하는 경향은 흐름 제어에서 더 강하다. 직접 작성한 타입에서 산술 연산이나 비교 연산을 오버로드할 수는 있지만, 쇼트서킷 연산자에 대한 오버로드는 불가능하다. 이런 연산자를 오버로드할 수 있게 허용하면 제어 흐름이 달라질 수 있기 때문이다.

> 코틀린은 동적 바인딩보다 정적 바인딩을 더 선호한다.

- 코틀린은 타입 안전한, 합성적인 코딩 스타일을 장려한다.
- 확장 함수는 정적으로 바인딩된다.
- 기본적으로 클래스는 확장될 수 없고, 메서드는 다형적이지 않다.

여러분은 명시적으로 다형성과 상속을 활성화해야 한다. 리플렉션을 사용하고 싶으면 플랫폼별로 다른 리플렉션 라이브러리를 의존 관계에 추가해야만 한다. 코틀린은 동적으로 코드를 분석해 프로그래머를 안내해 주고, 코드 내비게이션을 자동화하며, 프로그램을 자동으로 변환할 수 있는 코틀린 언어를 잘 아는 IDE와 함께 사용하도록 만들어졌다.

> 코틀린은 특별한 경우를 좋아하지 않는다.

- 원시 타입과 참조 타입 사이에 구분이 없다.
- 코틀린 함수는 값을 반환하거나 아무것도 반환하지 않는다.

> 코틀린은 마이그레이션을 쉽게 하기 위해 자신의 규칙을 깬다.

자바와 코틀린 코드가 동시에 존재하도록 허용하기 위한 기능이 있다.

- `lateinit var`
