---
layout  : wiki
title   : 스트리트 코더(Street coder)
summary :
date    : 2025-03-10 20:00:00 +0900
updated : 2025-03-10 20:00:00 +0900
tag     : programming
toc     : true
public  : true
parent  : [[how-to]]
latex   : true
---
* TOC
{:toc}

# Street coder

## 거리로
### 요약
- 전문 소프트웨어 개발의 세계, 이 '거리'의 냉혹한 현실은 정규 교육에서 가르치지 않거나 우선하지 않는, 때로는 독학에서 완전히 놓치기 쉬운 일련의 기술을 요구한다.
- 새로운 소프트웨어 개발자들은 이론에 너무 신경 쓰거나 완전히 무시하는 경향이 있다. 결국 중간 어딘가를 찾게 되겠지만, 어떤 확실한 관점을 갖게 되면 이를 더 빠르게 얻을 수 있다.
- 최신 소프트웨어 개발은 20년 전보다 훨씬 더 복잡하다. 단순한 애플리케이션 하나를 개발하기 위해서도 다양한 수준의 엄청난 지식이 필요하다.
- 프로그래머는 소프트웨어를 직접 만들어 보는 것과 공부하는 것 사이의 딜레마에 직면한다. 좀 더 실용적인 방법으로 주제를 재구성하여 이를 극복할 수 있다.
- 작업할 내용에 대한 명확한 이해가 부족하면 프로그래밍이 일상적이고 지루한 작업이 되어 실제 생산성이 낮아진다. 하는 일을 더 잘 이해할수록 더 많은 기쁨을 얻게 될 것이다.

### 고찰
나는 내가 모르는 부분이 있을 때에 중요하지 않다 생각하면 간과하고 넘어가는 경향이 있다. 하지만 그럴 수록 나의 두려움은 커져간다. 작가는 '나의 불안함이 무능력보다 무지에서 비롯되었다'라고 한 뒤, 'PC 본체를 열고 내부를 보니 마음이 차분해졌다'고 한다.

어쩌면 내가 개발을 진행하며 느끼는 불안함 또한 그 무지에서 비롯된 것일지 모른다. 하긴, 내가하는 것을 모두 알고 있다면 그 불안함을 느끼겠는가? 어쩌면 작가의 좌우명처럼 나 또한 상자를 먼저 여는 것에 용기를 가져야 할지도 모른다. 대부분의 상자 속은 두려워하는 것보다는 덜 복잡하니 말이다.

무엇보다 그런 두려움은 일하는 시간을 줄일 수 있을 것이다. 소프트웨어 개발이 무엇인가? 사람이 하는 일을 더욱 편하게 해주는 것이 아닌가? 더욱 편하게 하는 것은 고객 뿐만이 아니다. 개발자도 마찬가지다. 내가 알고 있는 지식을 최대한 활용해서 일에 투자하는 시간을 줄이고 활용해라.

## 실용적인 이론
### 요약
- 컴퓨터 과학 이론은 지루할 수 있지만, 이론을 아는 것은 우리를 더 나은 개발자로 만들어준다.
- 타입은 일반적으로 강한 타이핑 언어에서 사용되는 것으로 알려져 있지만, 코드를 덜 작성하기 위해 사용될 수 있다.
- 타입을 사용하면 코드를 더 쉽게 설명할 수 있고, 주석을 덜 작성해도 된다.
- 값 타입과 참조 타입의 차이는 매우 크며, 값 타입을 알고 있으면 좀 더 효율적인 개발자가 될 수 있다.
- 문자열 내부가 어떻게 돌아가는지를 아는 것은 유용하며, 효율적인 개발에 도움이 된다.
- 배열은 빠르고 편리하지만 공개적으로 노출된 API에 가장 적합한 후보는 아닐 수 있다.
- 리스트는 동적으로 크기가 증가하는 경우에 유용하지만 그렇지 않을 경우 배열이 더 효율적이다.
- 연결 리스트는 독특한 데이터 구조이지만, 그 특성을 알면 딕셔너리 구조의 트레이드오프를 이해하는 데 도움이 된다.
- 딕셔너리는 빠른 키 검색에 유용하지만 GetHashCode()의 구현에 따라 성능이 크게 달라진다.
- 고유한 값을 갖는 리스트는 멋진 검색 성능을 위해 HashSet으로 표현할 수 있다.
- 스택은 특정한 단계를 추적하기 위한 훌륭한 데이터 구조다. 콜스택이 대표적이다.
- 콜스택이 작동하는 방식을 알면 값 타입이나 참조 타입이 성능에 미치는 영향을 보완할 수 있다. 

### 고찰
최근 동료에게 감명깊은 이야기를 들었다. CS 지식은 그저 컴퓨터 이론을 뜻하는 것이 아니라, 내가 알고 있는 지식 중에 비어있는 지식을 채우는 용도라는 말이었다. 이 말을 듣고 요즘의 나는 Why라는 질문의 중요성을 잊고 문제를 쳐나가는 데에 급급했다는 것을 깨달았다. 그저 돌아가기만 하면 정답인 줄로 착각했다. 그러나 무심코 지나갔던 부분이 골칫거리로 전락하는 일이 발생하고 만다.

스스로에게 질문을 던지자. 내가 무엇을 알고 있다고 생각하는게 진짜 알고 있는 것이 맞는가? 꼬리에 꼬리를 무는 질문을 가져보자. 이런 측면에서 각 자료구조와 타입을 이해하는 건 필수라고 볼 수 있다. 이 책은 그런 필수 지식을 학습할 수 있는 정신적 틀을 제공한다.

### 문자열
- 텍스트 데이터를 의미하며, 사람이 읽을 수 있다.

Java에서는 String 클래스로 구현되고, 불변이다.

#### 문자열 연결 (String Concatenation) 문제

왜 문제가 되는가?
```java
String result = "";
for (int i = 0; i < n; i++) {
    result = result + "데이터" + i;
}
```

1. **String의 불변성(Immutability)**:
    - Java에서 `String` 객체는 불변(immutable)이다. 즉, 한번 생성되면 내용을 변경할 수 없다.
    - 각 `String` 객체는 내부적으로 `char[]` 또는 Java 9부터는 `byte[]` 배열에 문자 데이터를 저장한다.

2. **힙 메모리 할당**:
    - 각 반복에서 `result + "데이터" + i` 연산 시 다음과 같은 일이 발생한다:
        - 현재 `result` 문자열의 내용을 읽는다.
        - "데이터" 문자열을 읽는다.
        - `i`를 문자열로 변환한다.
        - 세 문자열을 합친 길이의 새로운 `char[]` 또는 `byte[]` 배열을 힙에 할당한다.
        - 세 문자열의 내용을 새 배열에 복사한다.
        - 새 배열을 참조하는 새 `String` 객체를 생성한다.
        - 새 `String` 객체의 참조를 `result` 변수에 할당한다.

3. **가비지 컬렉션 부담**:
    - 각 반복에서 이전 `result` 문자열은 더 이상 참조되지 않아 가비지 컬렉션 대상이 된다.
    - n번 반복하면 n개의 중간 문자열 객체가 생성되고 폐기된다.

4. **시간 복잡도**:
    - i번째 반복에서 i 길이의 문자열을 복사해야 하므로 전체 시간 복잡도는 O(1+2+3+...+n) = O(n²)가 된다.

#### 2. 문자열 분할 (String Splitting) 문제

왜 문제가 되는가?
```java
for (int i = 0; i < iterations; i++) {
    String[] parts = text.split("\\s+");
}
```

1. **정규식 패턴 컴파일**:
    - `split("\\s+")` 호출마다 내부적으로 `Pattern.compile("\\s+")` 작업이 수행된다.
    - 정규식 패턴 컴파일은 CPU 집약적인 작업으로, 다음 단계가 필요하다:
        - 정규식 구문 파싱
        - 상태 기계(State Machine) 생성
        - 최적화 수행
    - 컴파일된 패턴은 `Pattern` 객체로 힙 메모리에 저장된다.

2. **메모리 할당**:
    - 매 반복마다 새 `Pattern` 객체가 힙에 할당된다.
    - 각 `Pattern` 객체는 내부적으로 복잡한 데이터 구조(상태 전이 테이블, 그룹 정보 등)를 포함한다.
    - `split` 작업 결과로 새로운 문자열 배열(`String[]`)이 할당된다.

3. **CPU 캐시 비효율**:
    - 반복적인 패턴 컴파일은 CPU 캐시를 효율적으로 활용하지 못한다.
    - 재사용 대신 매번 새로운 계산을 수행하므로 명령어 캐시와 데이터 캐시의 효율이 떨어진다.

#### 문자열 인턴 (String Interning) 활용

왜 문제가 되는가?
```java
String s1 = new String("문자열");
String s2 = new String("문자열");
```

1. **문자열 리터럴과 String 객체**:
    - `"문자열"` 리터럴은 자바 클래스 로딩 시 문자열 상수 풀(String Constant Pool)에 저장된다.
    - `new String("문자열")`은 두 가지 객체를 생성한다:
        - 이미 상수 풀에 있는 "문자열" 리터럴
        - 힙 메모리에 새로 할당되는 `String` 객체 (리터럴의 내용을 복사함)

2. **메모리 중복**:
    - 동일한 내용의 `String` 객체가 여러 개 생성되면 각각 별도의 메모리 공간을 차지한다.
    - 애플리케이션에서 많은 중복 문자열이 있을 경우 상당한 메모리 낭비가 발생한다.

3. **String Constant Pool의 구조**:
    - JVM의 문자열 상수 풀은 Java 7부터 PermGen에서 힙 메모리로 이동했다.
    - 내부적으로 해시 테이블 구조를 사용하여 문자열을 저장하고 조회한다.
    - `intern()` 메소드는 이 풀에서 동일한 내용의 문자열을 찾거나, 없으면 추가한다.

#### 대용량 문자열 처리: 메모리 맵 파일

왜 문제가 되는가?
```java
String content = new String(Files.readAllBytes(Paths.get(filePath)));
```

1. **물리적 메모리 제한**:
    - `readAllBytes()`는 파일 전체를 바이트 배열로 로드한다.
    - 큰 파일(수백 MB 이상)은 Java 힙의 상당 부분을 차지할 수 있다.
    - 힙 메모리가 부족하면 `OutOfMemoryError`가 발생한다.

2. **배열 크기 제한**:
    - Java 배열은 `Integer.MAX_VALUE`(약 2GB) 크기 제한이 있다.
    - 2GB 이상의 파일은 단일 배열로 로드할 수 없다.

3. **가비지 컬렉션 압박**:
    - 대용량 문자열 객체는 가비지 컬렉션에 부담을 준다.
    - 큰 객체는 Old Generation에 바로 할당되며, Full GC 빈도를 증가시킨다.
    - Full GC는 애플리케이션 일시 중지(Stop-the-World)를 유발한다.

4. **메모리 매핑의 원리**:
    - 메모리 맵 파일은 운영체제의 가상 메모리 시스템을 활용한다.
    - 파일 데이터를 직접 메모리에 로드하지 않고, 필요할 때 페이지 단위(보통 4KB)로 로드한다.
    - 메모리 맵은 프로세스의 가상 주소 공간을 사용하지만 물리적 메모리(RAM)는 실제 접근 시에만 사용한다.

#### 문자열 풀 및 캐싱 전략

왜 문제가 되는가?
```java
public String getFormattedValue(int value) {
    return "Value: " + value;
}
```

1. **문자열 생성 비용**:
    - 매 메소드 호출마다 새로운 문자열 객체가 생성된다.
    - 문자열 생성은 다음 단계를 포함한다:
        - "Value: " 리터럴 접근
        - value를 문자열로 변환
        - 문자열 연결을 위한 StringBuilder 생성 (컴파일러 최적화)
        - 결과 문자열을 위한 char[] 또는 byte[] 할당
        - 새 String 객체 생성

2. **캐시 라인과 지역성**:
    - 반복적인 동일 값 요청은 CPU 캐시 지역성(locality)을 활용하지 못한다.
    - 캐시 미스(cache miss)가 증가하여 메모리 접근 지연 시간이 늘어난다.

3. **캐싱의 원리**:
    - `ConcurrentHashMap`은 내부적으로 해시 테이블 배열과 노드를 사용한다.
    - 자주 사용되는 값의 문자열은 한 번만 생성되고 재사용된다.
    - 동시성 제어를 위한 세그먼트 락(Java 7) 또는 CAS(Compare-And-Swap, Java 8+) 연산을 사용한다.

#### 6. 문자열 비교 최적화

왜 문제가 되는가?
```java
if (s.equals(target)) {
    return true;
}
```

1. **equals() 메소드의 동작**:
    - `String.equals()`는 다음 단계로 작동한다:
        - 참조 동일성 검사 (s == target)
        - 길이 비교 (s.length() == target.length())
        - 각 문자를 한 글자씩 순회하며 비교
    - 긴 문자열에서 마지막 글자만 다를 경우 거의 모든 글자를 비교해야 한다.

2. **CPU 파이프라인과 분기 예측**:
    - 문자열 비교는 조건부 분기를 유발한다.
    - 문자 비교 루프는 CPU 파이프라인과 분기 예측기에 부담을 준다.
    - 일치하지 않는 문자가 나올 때까지 계속 반복한다.

3. **해시코드의 활용**:
    - 문자열의 해시코드는 내용을 기반으로 계산된다.
    - 해시코드가 다르면 문자열이 다르다는 것이 확실하다(다른 내용이 같은 해시코드를 가질 수 있지만, 같은 내용이 다른 해시코드를 가질 수는 없다).
    - 해시코드는 String 객체에 캐싱되므로 재계산되지 않는다.

4. **메모리 접근 패턴**:
    - 최적화된 비교는 순차적인 메모리 접근을 줄여준다.
    - 길이와 해시코드 비교는 단일 정수 비교로, 문자열 내용 전체를 검사하는 것보다 캐시 효율적이다.

### 배열

### 리스트

### 딕셔너리

### 스택


## 유용한 안티패턴
### 요약

### 고찰

## 맛있는 테스트
### 요약

### 고찰

## 보람 있는 리팩터링
### 요약

### 고찰

## 조사를 통한 보안
### 요약

### 고찰

## 자기 주장이 뚜렷한 최적화
### 요약

### 고찰

## 기분 좋은 확장성
### 요약

### 고찰

## 버그와의 동거
### 요약

### 고찰
